# Minimum Number of Taps to Water a Garden

## Problem Description
Given a garden of length `n` and an array `ranges` where `ranges[i]` represents the coverage of tap `i` (from `i - ranges[i]` to `i + ranges[i]`), determine the minimum number of taps needed to water the entire garden (from 0 to n). Return -1 if it's impossible.

## Approach
The solution uses a **greedy algorithm** to determine the optimal taps:
1. **Preprocessing**: Create an array `maxRange` where `maxRange[i]` stores the farthest position that can be watered starting from position `i`.
2. **Greedy Selection**: Iterate through the garden, always choosing the tap that covers the farthest position from the current position.

### Key Steps:
1. **Calculate Coverage**: For each tap, determine its coverage range and update `maxRange`.
2. **Select Taps**: Use a greedy approach to select taps that cover the farthest possible positions from the current position.

## Solution Code
```cpp
class Solution {
public:
    int minTaps(int n, vector<int>& ranges) {
        vector<int> maxRange(n + 1, 0);
        
        // Preprocess to find the farthest position each point can reach
        for (int i = 0; i <= n; ++i) {
            int start = max(0, i - ranges[i]);
            int end = min(n, i + ranges[i]);
            maxRange[start] = max(maxRange[start], end);
        }
        
        int taps = 0;
        int currEnd = 0;
        int farthest = 0;
        
        for (int i = 0; i <= n; ++i) {
            farthest = max(farthest, maxRange[i]);
            
            // If current position is beyond the farthest reachable, it's impossible
            if (i > farthest) {
                return -1;
            }
            
            // When we reach the current end, select a new tap
            if (i == currEnd) {
                if (i != n) {
                    taps++;
                    currEnd = farthest;
                }
            }
        }
        
        return taps;
    }
};
```

## Explanation
1. **Preprocessing**:
   - For each tap, calculate its coverage range (`start` to `end`).
   - Update `maxRange[start]` to store the farthest position that can be watered starting from `start`.

2. **Greedy Selection**:
   - Initialize `currEnd` to 0 and `farthest` to 0.
   - Iterate through each position in the garden:
     - Update `farthest` to the maximum reachable position from the current position.
     - If the current position exceeds `farthest`, return -1 (impossible to cover).
     - When reaching `currEnd`, increment the tap count and update `currEnd` to `farthest`.

3. **Result**:
   - Return the number of taps used if the entire garden is covered; otherwise, return -1.

## Complexity Analysis
- **Time Complexity**: O(n) - We process each tap and each position in the garden once.
- **Space Complexity**: O(n) - We use an additional array `maxRange` of size `n + 1`. 

This approach efficiently determines the minimum number of taps needed by leveraging preprocessing and greedy selection to maximize coverage at each step.