# Best Time to Buy and Sell Stock III

## Problem Description
Given an array `prices` where `prices[i]` is the price of a given stock on the `i-th` day, find the maximum profit you can achieve with at most two transactions (buy + sell = one transaction).

## Approach
The solution uses **dynamic programming** to track the maximum profit considering:
1. **State Variables**:
   - `idx`: Current day
   - `buy`: Whether we can buy (1) or must sell (0)
   - `cap`: Number of transactions remaining (2, 1, or 0)

2. **DP Transition**:
   - If buying: Choose between buying today or skipping
   - If selling: Choose between selling today or skipping

3. **Space Optimization**:
   - Uses only two 2D vectors (`prev` and `curr`) instead of a 3D array

## Solution Code
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> prev(2, vector<int>(3, 0));
        vector<vector<int>> curr(2, vector<int>(3, 0));

        for(int idx = n-1; idx >= 0; idx--) {
            for(int buy = 0; buy <= 1; buy++) {
                for(int cap = 1; cap <= 2; cap++) {
                    if(buy == 1) {
                        // Can buy: choose between buying or skipping
                        curr[buy][cap] = max(-prices[idx] + prev[0][cap], 
                                             prev[1][cap]);
                    }
                    else {
                        // Must sell: choose between selling or skipping
                        curr[buy][cap] = max(prices[idx] + prev[1][cap-1], 
                                             prev[0][cap]);
                    }
                }
            }
            prev = curr;
        }

        return prev[1][2];
    }
};
```

## Explanation
1. **Initialization**: 
   - `prev` and `curr` DP tables track profits for previous and current days
   - Initialize all profits to 0 when no transactions remain (`cap=0`)

2. **Backward Induction**:
   - Process days from last to first
   - For each day, consider both buying and selling states
   - For each remaining transaction count (1 or 2)

3. **State Transitions**:
   - **Buying**: Max of (buy today + future profit from selling, skip buying)
   - **Selling**: Max of (sell today + future profit with one less transaction, skip selling)

4. **Result**: The maximum profit starting from day 0 with 2 transactions available (`prev[1][2]`)

## Complexity Analysis
- **Time Complexity**: O(n) - Processes each day exactly once
- **Space Complexity**: O(1) - Uses constant space with two 2x3 tables

This approach efficiently computes the maximum profit for at most two transactions while optimizing space usage.