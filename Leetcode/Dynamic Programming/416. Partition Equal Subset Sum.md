# Partition Equal Subset Sum

## Problem Description
Given a non-empty array `nums` containing only positive integers, determine if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.

### Examples
- **Example 1**:
  - Input: `nums = [1,5,11,5]`
  - Output: `true`
  - Explanation: The array can be partitioned as [1, 5, 5] and [11].

- **Example 2**:
  - Input: `nums = [1,2,3,5]`
  - Output: `false`
  - Explanation: The array cannot be partitioned into equal sum subsets.

### Constraints
- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`

## Approach
This problem can be solved using **dynamic programming** to check if a subset of numbers sums up to half of the total sum.

### Key Insights:
1. **Total Sum Check**: If the total sum is odd, it's impossible to partition into two equal subsets.
2. **Subset Sum Problem**: We need to find a subset that sums to `sum/2`.
3. **DP Table**: A 2D DP table where `dp[i][j]` represents whether the sum `j` can be achieved using the first `i` elements.

### Solution Code
```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        int n = nums.size();
        for (int num : nums) sum += num;

        if (sum % 2 != 0) return false;

        int target = sum / 2;
        vector<vector<bool>> dp(n + 1, vector<bool>(target + 1, false));

        // Base case: sum 0 can always be achieved with empty subset
        for (int i = 0; i <= n; i++) {
            dp[i][0] = true;
        }

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= target; j++) {
                if (nums[i - 1] > j) {
                    dp[i][j] = dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
                }
            }
        }

        return dp[n][target];
    }
};
```

## Explanation
1. **Initial Check**: Calculate the total sum. If it's odd, return `false` immediately.
2. **DP Table Initialization**: Create a DP table of size `(n+1) x (target+1)` where `target = sum/2`.
3. **Base Case**: The sum `0` can always be achieved with an empty subset (`dp[i][0] = true` for all `i`).
4. **DP Table Population**:
   - For each number, decide whether to include it or not in the subset.
   - If the current number is greater than the current sum `j`, exclude it (`dp[i][j] = dp[i-1][j]`).
   - Otherwise, check if the sum can be achieved either by excluding or including the current number (`dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]]`).
5. **Result**: The value `dp[n][target]` indicates if the target sum can be achieved using all numbers.

## Complexity Analysis
- **Time Complexity**: O(n * target) - We fill a DP table of size `n x target`.
- **Space Complexity**: O(n * target) - We use a 2D DP table. This can be optimized to O(target) space using a 1D array.

This approach efficiently checks for the possibility of partitioning the array into two equal sum subsets using dynamic programming.