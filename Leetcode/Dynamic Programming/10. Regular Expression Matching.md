# Regular Expression Matching

## Problem Description
Implement regular expression matching with support for `'.'` and `'*'` where:
- `'.'` matches any single character
- `'*'` matches zero or more of the preceding element
The matching should cover the entire input string (not partial).

## Approach
The solution uses **dynamic programming with memoization** to efficiently match the string against the pattern:

1. **Base Case**: If pattern is exhausted, check if string is also exhausted
2. **Memoization**: Store already computed results to avoid redundant calculations
3. **Character Matching**:
   - Direct character match or `'.'` match
   - Handle `'*'` cases (zero or more repetitions)
4. **Recursion**: Explore both possibilities when encountering `'*'`

### Key Insights:
- `'.'` acts as a wildcard for single characters
- `'*'` requires considering both zero and multiple occurrences of preceding character
- Memoization prevents exponential time complexity

## Solution Code
```cpp
class Solution {
public:
    int dp[21][21]; // Memoization table
    
    bool memo(string& s, string& p, int i, int j) {
        if (j == p.size()) {
            return i == s.size();
        }
        
        // Return memoized result if available
        if (dp[i][j] != 0) {
            return dp[i][j] == 1;
        }

        bool first_char_match = (i < s.size()) && (s[i] == p[j] || p[j] == '.');

        // Handle '*' case
        if (j + 1 < p.size() && p[j + 1] == '*') {
            bool take = first_char_match && memo(s, p, i + 1, j); // Use *
            bool not_take = memo(s, p, i, j + 2); // Skip *
            dp[i][j] = (take || not_take) ? 1 : -1;
            return dp[i][j] == 1;
        }

        // Simple match case
        dp[i][j] = (first_char_match && memo(s, p, i + 1, j + 1)) ? 1 : -1;
        return dp[i][j] == 1;
    }

    bool isMatch(string s, string p) {
        memset(dp, 0, sizeof(dp));
        return memo(s, p, 0, 0);
    }
};
```

## Explanation
1. **Initialization**: Clear memoization table before starting
2. **Base Case**: If pattern is fully processed (`j == p.size()`), check if string is also fully processed
3. **Memoization Check**: Return stored result if available
4. **First Character Match**:
   - Check if current characters match (direct or via `'.'`)
5. **Star Handling**:
   - Consider both using the star (repeat preceding character) and skipping it
6. **Simple Match**:
   - Proceed to next characters if current ones match
7. **Result Storage**: Store computed results in memoization table

## Complexity Analysis
- **Time Complexity**: O(m×n) where m and n are lengths of string and pattern
- **Space Complexity**: O(m×n) for memoization table

This approach efficiently handles the complex cases of regular expression matching while avoiding redundant computations through memoization.