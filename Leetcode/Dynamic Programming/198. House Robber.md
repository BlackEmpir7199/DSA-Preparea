# House Robber Problem Solution

## Problem Description
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, but adjacent houses have security systems connected. If two adjacent houses are robbed on the same night, the police will be alerted. Given an array `nums` representing the amount of money in each house, determine the maximum amount you can rob tonight without alerting the police.

## Approach
This problem can be solved using **dynamic programming** to make optimal decisions at each house while considering the constraint of not robbing adjacent houses.

### Key Insights:
1. **Decision at Each House**: For each house, you have two choices:
   - Rob the current house and add its money to the amount robbed from houses before the previous one.
   - Skip the current house and keep the amount robbed up to the previous house.
2. **Optimal Substructure**: The maximum amount at house `i` depends on the maximum amounts at houses `i-1` and `i-2`.

### Solution Code
```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int size = nums.size();
        if (size == 1) return nums[0];

        vector<int> dp(size);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);

        for (int i = 2; i < size; i++) {
            dp[i] = max(nums[i] + dp[i-2], dp[i-1]);
        }

        return dp[size-1];
    }
};
```

## Explanation
1. **Base Cases**:
   - If there's only one house, you can only rob that house (`nums[0]`).
   - If there are two houses, rob the one with more money (`max(nums[0], nums[1])`).

2. **Dynamic Programming Array**:
   - `dp[i]` represents the maximum amount that can be robbed up to the `i-th` house.
   - For each subsequent house, the robber can either:
     - Rob the current house and add its value to the amount robbed up to two houses back (`nums[i] + dp[i-2]`).
     - Skip the current house and keep the amount robbed up to the previous house (`dp[i-1]`).

3. **Result**:
   - The last element of the `dp` array (`dp[size-1]`) contains the maximum amount that can be robbed without alerting the police.

## Complexity Analysis
- **Time Complexity**: O(n) - We iterate through the array once.
- **Space Complexity**: O(n) - We use an additional array `dp` of size `n`.

This approach efficiently computes the maximum loot by leveraging dynamic programming to make optimal decisions at each step while respecting the constraint of not robbing adjacent houses.