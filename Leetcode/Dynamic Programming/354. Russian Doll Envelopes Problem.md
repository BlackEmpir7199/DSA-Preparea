# 354. Russian Doll Envelopes Problem

## Problem Description
Given a collection of envelopes represented by their widths and heights `[w, h]`, determine the maximum number of envelopes you can put one inside another (like Russian dolls). One envelope can fit into another if both its width and height are strictly smaller than the other envelope's.

## Approach
The solution combines sorting with the Longest Increasing Subsequence (LIS) algorithm:

1. **Sorting**: 
   - First sort envelopes by ascending width
   - For envelopes with same width, sort by descending height to prevent multiple envelopes of same width from being included in the solution

2. **Longest Increasing Subsequence**:
   - Extract just the heights after sorting
   - Find the LIS of these heights, which corresponds to the maximum nesting sequence

## Solution Code
```cpp
class Solution {
public:
    int maxEnvelopes(vector<vector<int>>& envelopes) {
        if (envelopes.empty()) return 0;

        // Step 1: Sort by width ascending, height descending
        sort(envelopes.begin(), envelopes.end(), [](const auto& a, const auto& b) {
            return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);
        });

        // Step 2: Extract heights
        vector<int> heights;
        for (const auto& env : envelopes) {
            heights.push_back(env[1]);
        }

        // Step 3: Find LIS on heights
        vector<int> lis;
        for (int h : heights) {
            auto it = lower_bound(lis.begin(), lis.end(), h);
            if (it == lis.end()) {
                lis.push_back(h);
            } else {
                *it = h;
            }
        }

        return lis.size();
    }
};
```

## Explanation
1. **Sorting**:
   - Envelopes are sorted primarily by width in ascending order
   - For envelopes with equal width, we sort by height in descending order to ensure only one envelope per width can be selected

2. **Height Sequence**:
   - After sorting, we extract just the height values into a separate array

3. **LIS Calculation**:
   - We maintain a `lis` vector that tracks the smallest possible tail values for increasing subsequences of various lengths
   - For each height, we use binary search (`lower_bound`) to find where it would fit in the `lis` sequence
   - If it's larger than all current elements, we extend the sequence
   - Otherwise, we replace the first element that's >= current height

## Complexity Analysis
- **Time Complexity**: O(n log n)
  - Sorting takes O(n log n)
  - LIS with binary search takes O(n log n)
- **Space Complexity**: O(n)
  - We store the sorted heights and the LIS sequence

This approach efficiently finds the maximum nesting sequence by transforming the 2D problem into a 1D LIS problem through proper sorting.