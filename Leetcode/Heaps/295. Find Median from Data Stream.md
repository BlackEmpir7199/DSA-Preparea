# Find Median from Data Stream

## Problem Description
Design a data structure that supports adding numbers and finding the median of all numbers added so far. The median is the middle value in an ordered list. If the size is even, the median is the average of the two middle numbers.

## Approach
The solution uses **two heaps** to efficiently track and maintain the median:
1. **Max-Heap**: Stores the smaller half of numbers
2. **Min-Heap**: Stores the larger half of numbers
3. **Balancing**: Ensures heaps differ in size by at most 1

### Key Operations:
- **addNum**: Adds a number to the appropriate heap and rebalances
- **findMedian**: Returns the median based on current heap sizes

## Solution Code
```cpp
class MedianFinder {
    priority_queue<double> maxHeap; // Stores smaller half (max at top)
    priority_queue<double, vector<double>, greater<double>> minHeap; // Stores larger half (min at top)
    
public:
    MedianFinder() {}
    
    void addNum(int num) {
        // Add to appropriate heap
        if (maxHeap.empty() || num <= maxHeap.top()) {
            maxHeap.push(num);
        } else {
            minHeap.push(num);
        }
        
        // Balance heaps
        if (maxHeap.size() > minHeap.size() + 1) {
            minHeap.push(maxHeap.top());
            maxHeap.pop();
        } else if (minHeap.size() > maxHeap.size()) {
            maxHeap.push(minHeap.top());
            minHeap.pop();
        }
    }
    
    double findMedian() {
        if (maxHeap.size() == minHeap.size()) {
            return (maxHeap.top() + minHeap.top()) / 2.0;
        } else {
            return maxHeap.top();
        }
    }
};
```

## Explanation
1. **Heap Selection**:
   - Numbers â‰¤ maxHeap.top() go to maxHeap
   - Others go to minHeap

2. **Balancing**:
   - If maxHeap has 2+ elements than minHeap, move top to minHeap
   - If minHeap is larger, move its top to maxHeap

3. **Median Calculation**:
   - Equal sizes: Average of both tops
   - Unequal: Top of larger heap (maxHeap)

## Complexity Analysis
- **addNum**: O(log n) per operation (heap insertion)
- **findMedian**: O(1) (accessing heap tops)
- **Space**: O(n) (storing all elements)

This approach efficiently maintains median access while keeping insertion costs logarithmic.