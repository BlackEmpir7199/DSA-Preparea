# 547. Number of Provinces

## Problem Description
Given an `n x n` matrix `isConnected` where `isConnected[i][j] = 1` if the ith city and the jth city are directly connected, and `isConnected[i][j] = 0` otherwise, return the total number of provinces. A province is a group of directly or indirectly connected cities with no other cities outside the group.

### Examples
- **Example 1**:
  - Input: `isConnected = [[1,1,0],[1,1,0],[0,0,1]]`
  - Output: `2`
  - Explanation: Cities 0 and 1 are connected, forming one province, and city 2 is separate, forming another.

- **Example 2**:
  - Input: `isConnected = [[1,0,0],[0,1,0],[0,0,1]]`
  - Output: `3`
  - Explanation: Each city is its own province as none are connected.

### Constraints
- `1 <= n <= 200`
- `n == isConnected.length`
- `n == isConnected[i].length`
- `isConnected[i][j]` is `1` or `0`.
- `isConnected[i][i] == 1`
- `isConnected[i][j] == isConnected[j][i]`

## Approach
The solution uses **Depth-First Search (DFS)** to traverse the connected cities and count the number of provinces.

### Key Steps:
1. **Initialization**: Create a visited array to keep track of visited cities.
2. **DFS Traversal**: For each unvisited city, perform DFS to mark all connected cities as visited.
3. **Count Provinces**: Each DFS call from an unvisited city indicates a new province.

### Solution Code
```cpp
class Solution {
public:
    void dfs(vector<vector<int>>& isConnected, vector<bool>& visited, int node) {
        visited[node] = true;
        for (int i = 0; i < isConnected[node].size(); i++) {
            if (isConnected[node][i] == 0) continue;
            if (!visited[i]) {
                dfs(isConnected, visited, i);
            }
        }
    }

    int findCircleNum(vector<vector<int>>& isConnected) {
        int provinces = 0;
        int size = isConnected.size();
        vector<bool> visited(size, false);
        for (int i = 0; i < size; i++) {
            if (!visited[i]) {
                dfs(isConnected, visited, i);
                provinces++;
            }
        }
        return provinces;
    }
};
```

## Explanation
1. **DFS Function**: The `dfs` function marks the current city as visited and recursively visits all directly connected cities that haven't been visited yet.
2. **Main Function**: The `findCircleNum` function initializes the visited array and iterates over each city. If a city hasn't been visited, it starts a DFS from that city and increments the province count.
3. **Result**: The number of DFS calls initiated from unvisited cities gives the number of provinces.

## Complexity Analysis
- **Time Complexity**: `O(n^2)` - In the worst case, we might need to check all `n^2` entries in the matrix.
- **Space Complexity**: `O(n)` - The visited array uses `O(n)` space, and the recursion stack can go up to `O(n)` in depth.

This approach efficiently counts the number of connected components (provinces) in the graph represented by the adjacency matrix.