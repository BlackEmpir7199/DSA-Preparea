# 785. Check if a Graph is Bipartite

## Problem Description
Given an undirected graph represented as an adjacency list, determine if the graph is bipartite. A graph is bipartite if its vertices can be divided into two disjoint sets such that no two graph vertices within the same set are adjacent.

### Examples
- **Example 1**:
  - Input: `graph = [[1,3],[0,2],[1,3],[0,2]]`
  - Output: `true`
  - Explanation: The graph can be divided into two sets {0, 2} and {1, 3} with no edges within the same set.

- **Example 2**:
  - Input: `graph = [[1,2,3],[0,2],[0,1,3],[0,2]]`
  - Output: `false`
  - Explanation: Cannot divide the graph into two sets without having edges within the same set.

### Constraints
- `1 <= graph.length <= 100`
- `0 <= graph[i].length < 100`
- `graph[i][j]` is in the range `[0, graph.length - 1]`
- `graph[i]` does not contain `i` (no self-loops)
- All values in `graph[i]` are unique
- The graph is undirected

## Approach
The solution uses **Breadth-First Search (BFS)** to check if the graph is bipartite by attempting to color the graph with two colors such that no two adjacent nodes have the same color.

### Key Steps:
1. **Initialization**: Create a colors array initialized to -1 (uncolored) and a queue for BFS.
2. **BFS Traversal**: For each uncolored node, assign a color and perform BFS. For each neighbor:
   - If uncolored, assign the opposite color and enqueue.
   - If already colored with the same color as the current node, the graph is not bipartite.
3. **Result**: If BFS completes without conflicts for all nodes, the graph is bipartite.

### Solution Code
```cpp
class Solution {
public:
    bool isBipartite(vector<vector<int>>& graph) {
        queue<int> q;
        vector<int> colors(graph.size(), -1);

        for (int j = 0; j < graph.size(); j++) {
            if (colors[j] == -1) {
                colors[j] = 1;
                q.push(j);
                while (!q.empty()) {
                    int node = q.front(); q.pop();
                    for (int i : graph[node]) {
                        if (colors[i] == -1) {
                            colors[i] = !colors[node];
                            q.push(i);
                        }
                        else if (colors[i] == colors[node]) {
                            return false;
                        }
                    }
                }
            }
        }

        return true;
    }
};
```

## Explanation
1. **Initialization**: The `colors` array tracks the color (0 or 1) of each node, initialized to -1 (uncolored).
2. **BFS Loop**: For each uncolored node, start BFS:
   - Assign the starting node a color (1).
   - For each neighbor:
     - If uncolored, assign the opposite color and enqueue.
     - If colored and matches the current node's color, return `false`.
3. **Termination**: If BFS completes for all nodes without color conflicts, return `true`.

## Complexity Analysis
- **Time Complexity**: `O(V + E)` - Each node and edge is visited once.
- **Space Complexity**: `O(V)` - The colors array and queue use `O(V)` space.

This approach efficiently checks for bipartiteness by leveraging BFS and two-coloring, ensuring optimal performance for the given constraints.