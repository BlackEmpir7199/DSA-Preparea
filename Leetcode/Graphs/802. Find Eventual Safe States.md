# 802. Find Eventual Safe States

## Problem Description
Given a directed graph, we want to find all nodes that are "eventual safe" nodes. A node is eventual safe if all possible paths starting from that node lead to a terminal node (a node without outgoing edges) or another eventual safe node.

### Examples
- **Example 1**:
  - Input: `graph = [[1,2],[2,3],[5],[0],[5],[],[]]`
  - Output: `[2,4,5,6]`
  - Explanation: Nodes 5 and 6 are terminal nodes. Node 2 leads to node 5, node 4 leads to node 5, and nodes 5 and 6 have no outgoing edges.

- **Example 2**:
  - Input: `graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]`
  - Output: `[4]`
  - Explanation: Only node 4 is a terminal node, and nodes 0, 1, 2, and 3 form a cycle.

### Constraints
- `1 <= graph.length <= 10^4`
- `0 <= graph[i].length <= 10^4`
- `graph[i]` is sorted in a unique order.
- The input graph may contain self-loops and parallel edges.

## Approach
The solution uses **topological sorting** to identify eventual safe nodes by working backward from terminal nodes (nodes with no outgoing edges).

### Key Steps:
1. **Reverse the Graph**: Instead of tracking outgoing edges, track incoming edges to each node.
2. **Calculate Out-Degrees**: For each node, count its outgoing edges.
3. **Topological Sort**: Start with terminal nodes (out-degree 0) and work backward, reducing out-degrees of nodes that point to them. If a node's out-degree becomes 0, it is marked as safe.
4. **Collect Safe Nodes**: After processing, all nodes with out-degree 0 are eventual safe nodes.

### Solution Code
```cpp
class Solution {
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int n = graph.size();

        vector<int> outDeg(n, 0);
        queue<int> q;
        vector<vector<int>> inEdge(n);
        vector<int> safe(n, 0);
        vector<int> ans;
        
        // Build inEdge and calculate outDeg
        for(int i = 0; i < n; i++) {
            for(int node : graph[i]) {
                inEdge[node].push_back(i);
            }
            outDeg[i] = graph[i].size();
            if(outDeg[i] == 0) q.push(i);
        }

        // Topological sort
        while(!q.empty()) {
            int node = q.front(); q.pop();
            safe[node] = 1;
            for(int inEdgeNode : inEdge[node]) {
                outDeg[inEdgeNode]--;
                if(outDeg[inEdgeNode] == 0) q.push(inEdgeNode);
            }
        }

        // Collect safe nodes
        for(int i = 0; i < n; i++) {
            if(safe[i] == 1) ans.push_back(i);
        }

        return ans;
    }
};
```

## Explanation
1. **Graph Reversal**: We create an `inEdge` adjacency list to track incoming edges to each node.
2. **Out-Degree Calculation**: For each node, we count its outgoing edges (`outDeg`). Nodes with `outDeg = 0` are terminal nodes and are added to the queue.
3. **Topological Processing**: We process nodes in the queue (terminal nodes), reducing the out-degree of nodes that have edges to them. If a node's out-degree becomes 0, it is added to the queue.
4. **Result Collection**: After processing, nodes marked as safe (out-degree 0) are collected and returned in sorted order.

## Complexity Analysis
- **Time Complexity**: `O(V + E)` - Each node and edge is processed once.
- **Space Complexity**: `O(V + E)` - We store the graph, in-edges, and out-degrees.

This approach efficiently identifies eventual safe nodes by leveraging topological sorting, ensuring optimal performance for large graphs.