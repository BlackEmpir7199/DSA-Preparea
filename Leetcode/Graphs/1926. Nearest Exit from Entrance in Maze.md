# 1926. Nearest Exit from Maze Entrance

## Problem Description
Given an `m x n` maze represented by a grid where:
- `'.'` represents an empty cell you can walk through
- `'+'` represents a wall you cannot walk through
- `ent = [entrance_row, entrance_col]` denotes your starting position

Find the number of steps in the shortest path from the entrance to the nearest exit. An exit is defined as any empty cell on the border of the maze that is not the entrance. If no exit exists, return `-1`.

## Approach
We use **Breadth-First Search (BFS)** to explore the maze level by level from the entrance. This guarantees that the first exit we find will be the nearest one.

### Key Steps:
1. **Initialization**: Start BFS from the entrance position.
2. **Level-wise Traversal**: For each level (step), explore all reachable cells.
3. **Exit Check**: If we reach any border cell (that's not the entrance), return the current step count.
4. **Mark Visited**: Mark cells as visited by changing them to `'+'` to avoid revisiting.

## Solution Code
```cpp
class Solution {
public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
        queue<pair<int, int>> q;
        vector<pair<int, int>> directions = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};
        
        int rows = maze.size();
        int cols = maze[0].size();
        
        // Check if entrance is blocked
        if (maze[entrance[0]][entrance[1]] == '+') 
            return -1;
        
        q.push({entrance[0], entrance[1]});
        maze[entrance[0]][entrance[1]] = '+'; // Mark entrance as visited
        int steps = 0;
        
        while (!q.empty()) {
            int level_size = q.size();
            for (int i = 0; i < level_size; i++) {
                auto [x, y] = q.front();
                q.pop();
                
                // Check if current cell is an exit (and not the entrance)
                if ((x == 0 || y == 0 || x == rows-1 || y == cols-1) && 
                    !(x == entrance[0] && y == entrance[1])) {
                    return steps;
                }
                
                // Explore all four directions
                for (auto [dx, dy] : directions) {
                    int newX = x + dx;
                    int newY = y + dy;
                    
                    // Check boundaries and if cell is walkable
                    if (newX >= 0 && newX < rows && newY >= 0 && newY < cols && 
                        maze[newX][newY] == '.') {
                        q.push({newX, newY});
                        maze[newX][newY] = '+'; // Mark as visited
                    }
                }
            }
            steps++;
        }
        
        return -1; // No exit found
    }
};
```

## Explanation
1. **Initialization**: We start BFS from the entrance position and mark it as visited.
2. **Level Processing**: For each level (representing one step), we process all cells at that level.
3. **Exit Check**: Before exploring neighbors, we check if the current cell is on the border (and not the entrance).
4. **Neighbor Exploration**: For each valid neighbor (within bounds and walkable), we add it to the queue and mark it as visited.
5. **Termination**: If we find an exit, return the step count. If queue empties without finding an exit, return `-1`.

## Complexity Analysis
- **Time Complexity**: O(m×n) - In the worst case, we visit every cell once.
- **Space Complexity**: O(m×n) - The queue may store all cells in the worst case.

This BFS approach efficiently finds the shortest path to the nearest exit while avoiding revisiting cells.