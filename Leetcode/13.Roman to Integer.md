# Roman to Integer
## Problem Description

Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D`, and `M`, each with the following values:

| Symbol | Value |
|--------|-------|
| I      | 1     |
| V      | 5     |
| X      | 10    |
| L      | 50    |
| C      | 100   |
| D      | 500   |
| M      | 1000  |

### Rules:
1. Roman numerals are generally written largest to smallest from left to right (e.g., `III` = 3, `XII` = 12).
2. For specific cases involving subtraction:
   - `I` can precede `V` (5) and `X` (10) to make 4 (`IV`) and 9 (`IX`).
   - `X` can precede `L` (50) and `C` (100) to make 40 (`XL`) and 90 (`XC`).
   - `C` can precede `D` (500) and `M` (1000) to make 400 (`CD`) and 900 (`CM`).

Given a Roman numeral string, convert it to its integer equivalent.

---

## Examples

### Example 1:
**Input**:  
`s = "III"`

**Output**:  
`3`

**Explanation**:  
`III = 3`

---

### Example 2:
**Input**:  
`s = "LVIII"`

**Output**:  
`58`

**Explanation**:  
`L = 50, V = 5, III = 3`

---

### Example 3:
**Input**:  
`s = "MCMXCIV"`

**Output**:  
`1994`

**Explanation**:  
`M = 1000, CM = 900, XC = 90, IV = 4`

---

## Constraints
- `1 <= s.length <= 15`
- `s` contains only the characters `'I', 'V', 'X', 'L', 'C', 'D', 'M'`.
- It is guaranteed that `s` is a valid Roman numeral in the range `[1, 3999]`.

---

## Solution

### Approach:
1. **Create a Mapping**:
   - Use a `HashMap` to store the values of each Roman numeral for fast lookup.

2. **Iterate Through the String**:
   - Traverse the Roman numeral string character by character.
   - Compare the value of the current numeral with the previous numeral.
     - If the current value is greater than the previous value, it indicates a subtraction case. Subtract twice the previous value from the total (once to reverse the addition, and once to account for subtraction).
     - Otherwise, simply add the current value to the total.

3. **Return the Total**:
   - After iterating through the string, return the computed total.

---

### Code Implementation

```java
class Solution {
    public int romanToInt(String s) {
        HashMap<Character, Integer> map = new HashMap<>();
        map.put('I', 1);
        map.put('V', 5);
        map.put('X', 10);
        map.put('L', 50);
        map.put('C', 100);
        map.put('D', 500);
        map.put('M', 1000);

        int total = 0;
        for (int i = 0; i < s.length(); i++) {
            // Check if the current numeral is larger than the previous one
            if (i > 0 && map.get(s.charAt(i)) > map.get(s.charAt(i - 1))) {
                total += map.get(s.charAt(i)) - 2 * map.get(s.charAt(i - 1));
            } else {
                total += map.get(s.charAt(i));
            }
        }
        return total;
    }
}
```

---

## Complexity Analysis

### Time Complexity:
- **O(n)**: The solution involves iterating through the input string once, where `n` is the length of the string.

### Space Complexity:
- **O(1)**: The `HashMap` contains a fixed set of mappings, and no additional space is used relative to the input size.

---

## Usage

1. **Input**: Provide a Roman numeral string to the function `romanToInt()`.
2. **Output**: The function will return the integer equivalent of the Roman numeral.

---

## Edge Cases
1. **Single Character Input**:  
   Input: `"I"`  
   Output: `1`

2. **All Subtraction Cases**:  
   Input: `"IVIXXLXC"`  
   Output: Corresponding integer value.

3. **Large Input**:  
   Input: `"MMMCMXCIX"` (maximum value, 3999)  
   Output: `3999`

---

## Notes
- Ensure the input string adheres to the constraints (`1 <= s.length <= 15` and valid Roman numerals).
- The solution uses a subtraction logic for cases like `IV`, `IX`, `XL`, etc., to correctly compute the result.

--- 